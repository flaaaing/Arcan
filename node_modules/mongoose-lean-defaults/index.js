'use strict';
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const mpath_1 = __importDefault(require("mpath"));
function mongooseLeanDefaults(schema) {
    const fn = attachDefaultsMiddleware(schema);
    schema.post('find', fn);
    schema.post('findOne', fn);
    schema.post('findOneAndUpdate', fn);
}
exports.default = mongooseLeanDefaults;
function attachDefaultsMiddleware(schema) {
    return function (res) {
        attachDefaults.call(this, schema, res);
    };
}
function attachDefaults(schema, res, depth = 0) {
    if (res == null) {
        return;
    }
    if (this._mongooseOptions.lean && this._mongooseOptions.lean.defaults) {
        const projection = this.projection() || {};
        let projectionInclude = null;
        let projectedFields = Object.keys(projection).filter((field) => field !== '_id');
        if (depth > 0) {
            const depthProjectedFields = [];
            for (let index = 0; index < projectedFields.length; index++) {
                const field = projectedFields[index];
                const newProjectedField = field.split('.').slice(depth).join('.');
                if (newProjectedField.length > 0) {
                    depthProjectedFields.push(newProjectedField);
                }
            }
            projectedFields = depthProjectedFields;
        }
        if (projectedFields.length > 0) {
            const definingProjection = projectedFields.find((prop) => projection[prop] != null && typeof projection[prop] !== 'object');
            if (definingProjection != null) {
                projectionInclude = !!projection[definingProjection];
            }
        }
        const defaults = [];
        schema.eachPath(function (pathname, schemaType) {
            if (projectionInclude !== null) {
                const included = projectedFields.some((path) => pathname.indexOf(path) === 0 || path.indexOf(pathname) === 0);
                if (projectionInclude && !included) {
                    return;
                }
                else if (!projectionInclude && included) {
                    return;
                }
            }
            if (schemaType.options &&
                Object.prototype.hasOwnProperty.call(schemaType.options, 'default')) {
                defaults.push({ path: pathname, default: schemaType.options.default });
            }
            else if (schemaType.defaultValue !== undefined) {
                defaults.push({ path: pathname, default: schemaType.defaultValue });
            }
            else if (schemaType.instance === 'Array') {
                defaults.push({ path: pathname, default: [] });
            }
            else if (pathname.includes('.')) {
                defaults.push({ path: pathname, default: undefined });
            }
        });
        let toApply = defaults;
        if (Array.isArray(this._mongooseOptions.lean.defaults)) {
            toApply = defaults.filter(({ path }) => this._mongooseOptions.lean.defaults.includes(path));
        }
        let _ret;
        if (Array.isArray(res)) {
            for (let i = 0; i < res.length; ++i) {
                attachDefaultsToDoc(schema, res[i], toApply);
            }
            _ret = res;
        }
        else {
            _ret = attachDefaultsToDoc(schema, res, toApply);
        }
        for (let i = 0; i < schema.childSchemas.length; ++i) {
            const _path = schema.childSchemas[i].model.path;
            const _schema = schema.childSchemas[i].schema;
            const _doc = mpath_1.default.get(_path, res);
            if (_doc == null) {
                continue;
            }
            attachDefaults.call(this, _schema, _doc, depth + 1);
        }
        return _ret;
    }
    else {
        return res;
    }
}
function attachDefaultsToDoc(schema, doc, defaults) {
    if (doc == null)
        return;
    if (Array.isArray(doc)) {
        for (let i = 0; i < doc.length; ++i) {
            attachDefaultsToDoc(schema, doc[i], defaults);
        }
        return;
    }
    for (let i = 0; i < defaults.length; ++i) {
        const defaultToApply = defaults[i];
        if (!mpath_1.default.has(defaultToApply.path, doc)) {
            const pathSegments = defaultToApply.path.split('.');
            let cur = doc;
            for (let j = 0; j < pathSegments.length - 1; ++j) {
                cur[pathSegments[j]] = cur[pathSegments[j]] || {};
                cur = cur[pathSegments[j]];
            }
            let _default = defaultToApply.default;
            if (typeof _default === 'function') {
                _default = _default.call(doc, doc);
            }
            cur[pathSegments[pathSegments.length - 1]] = _default;
        }
    }
}
